%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Quantum Computing Project}
\date{Mar 15, 2024}
\release{0.01}
\author{
Conner Adlington, Julia Bauer, etc.\@{} 
}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\index{module@\spxentry{module}!example@\spxentry{example}}\index{example@\spxentry{example}!module@\spxentry{module}}

\chapter{Name The Chapter Up Here}
\label{\detokenize{index:name-the-chapter-up-here}}\label{\detokenize{index:module-example}}
\sphinxAtStartPar
This narrative can explain the whole point of the module (the file).

\sphinxAtStartPar
You can include maths inline like this: \(a^2 + b^2 = c^2\)

\sphinxAtStartPar
Or, if you need to display, do it like this (be sure to leave a blank line
above the .. math:: delcaration):
\begin{equation*}
\begin{split}\lim_{n\to\infty} \frac{1}{n} \neq \infty\end{split}
\end{equation*}
\sphinxAtStartPar
We can make use of referencing code objects like classes and methods
like this:

\sphinxAtStartPar
In this chapter we will start by explaining the {\hyperref[\detokenize{index:example.Example}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Example}}}}} class
and the required arguments for the \sphinxcode{\sphinxupquote{\_\_init\_\_()}} method.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Add notes like this.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Add warnings like this.
\end{sphinxadmonition}

\sphinxAtStartPar
Insert code sample with backticks \sphinxtitleref{def \_\_init\_\_()}.
Make text \sphinxstylestrong{bold}, or \sphinxstyleemphasis{italics} just like markdown.
\begin{description}
\sphinxlineitem{This is a list:}\begin{itemize}
\item {} 
\sphinxAtStartPar
With

\item {} 
\sphinxAtStartPar
Bullets.

\end{itemize}

\sphinxlineitem{This is also a list:}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
With

\item {} 
\sphinxAtStartPar
Numbers.

\end{enumerate}

\end{description}
\index{Example (class in example)@\spxentry{Example}\spxextra{class in example}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:example.Example}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{example.}}\sphinxbfcode{\sphinxupquote{Example}}}{\sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Class explanation.

\sphinxAtStartPar
This can be a high level overview of what the object is.
\index{arg1 (example.Example attribute)@\spxentry{arg1}\spxextra{example.Example attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:example.Example.arg1}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{arg1}}}
\pysigstopsignatures
\sphinxAtStartPar
Describe the \sphinxtitleref{self.arg1} term.
This behaviour is unique to the init method.

\end{fulllineitems}

\index{usefulMethod() (example.Example method)@\spxentry{usefulMethod()}\spxextra{example.Example method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:example.Example.usefulMethod}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{usefulMethod}}}{\sphinxparam{\DUrole{n}{input}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Explain the utility of this method.
\begin{description}
\sphinxlineitem{Params:}\begin{description}
\sphinxlineitem{input:}
\sphinxAtStartPar
This \sphinxcode{\sphinxupquote{int}} should represent something.

\end{description}

\sphinxlineitem{Returns:}
\sphinxAtStartPar
This method returns a \sphinxcode{\sphinxupquote{Vector}}.

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\bigskip\hrule\bigskip

\index{Example2 (class in example)@\spxentry{Example2}\spxextra{class in example}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:example.Example2}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{example.}}\sphinxbfcode{\sphinxupquote{Example2}}}
\pysigstopsignatures
\sphinxAtStartPar
This is the second class

\end{fulllineitems}

\index{module@\spxentry{module}!qc@\spxentry{qc}}\index{qc@\spxentry{qc}!module@\spxentry{module}}

\chapter{Quantum Circuit Module}
\label{\detokenize{index:quantum-circuit-module}}\label{\detokenize{index:module-qc}}
\sphinxAtStartPar
This module provides the implementation of a quantum circuit simulator.
It defines the \sphinxtitleref{Circuit} class which represents a quantum circuit and
provides methods for applying quantum gates and running Grover’s algorithm.
\index{Circuit (class in qc)@\spxentry{Circuit}\spxextra{class in qc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:qc.Circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{qc.}}\sphinxbfcode{\sphinxupquote{Circuit}}}{\sphinxparam{\DUrole{n}{register\_size}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This is the quantum circuit class which represents a quantum circuit with a
specified register size. It provides methods for applying quantum gates,
running Grover’s algorithm, and measuring the result.
\index{grover() (qc.Circuit method)@\spxentry{grover()}\spxextra{qc.Circuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:qc.Circuit.grover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grover}}}{\sphinxparam{\DUrole{n}{target}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Runs Grover’s algorithm on the quantum circuit to find the target state.

\sphinxAtStartPar
This method calculates the number of iterations required for Grover’s
algorithm based on the register size and the target state. It then
constructs the Grover operator by combining the oracle, Hadamard gates,
and reflection operator.

\sphinxAtStartPar
The Grover operator is applied to the quantum register for the calculated
number of iterations to amplify the amplitude of the target state.
\begin{description}
\sphinxlineitem{Params:}
\sphinxAtStartPar
target (int): The target state to find using Grover’s algorithm.

\end{description}

\end{fulllineitems}

\index{h() (qc.Circuit method)@\spxentry{h()}\spxextra{qc.Circuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:qc.Circuit.h}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{h}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Applies the Hadamard gate to all qubits in the quantum register.

\sphinxAtStartPar
This method retrieves the Hadamard gate matrix from the \sphinxtitleref{gates} object,
raises it to the power of the register size to create a tensor product,
and then applies the resulting operator to the quantum register.

\sphinxAtStartPar
The quantum register is updated with the new state after applying the
Hadamard gate.

\end{fulllineitems}

\index{measure() (qc.Circuit method)@\spxentry{measure()}\spxextra{qc.Circuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:qc.Circuit.measure}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{measure}}}{\sphinxparam{\DUrole{n}{target}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Measures the quantum circuit and prints the probability of the target state.

\sphinxAtStartPar
This method performs a measurement on the quantum circuit to determine the
probability of observing the target state. It calculates the inner product
between the target state vector and the current state vector of the quantum
register.
\begin{description}
\sphinxlineitem{Params:}
\sphinxAtStartPar
target (int): The target state to measure the probability for.

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\bigskip\hrule\bigskip

\index{module@\spxentry{module}!utils.state\_vector@\spxentry{utils.state\_vector}}\index{utils.state\_vector@\spxentry{utils.state\_vector}!module@\spxentry{module}}\index{makeStateVector() (in module utils.state\_vector)@\spxentry{makeStateVector()}\spxextra{in module utils.state\_vector}}\phantomsection\label{\detokenize{index:module-utils.state_vector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.state_vector.makeStateVector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.state\_vector.}}\sphinxbfcode{\sphinxupquote{makeStateVector}}}{\sphinxparam{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{size}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Creates a state vector based on the given integer value.

\sphinxAtStartPar
The function takes an integer \sphinxtitleref{value} and an optional \sphinxtitleref{size} parameter. It converts
the integer to its binary representation and creates a tensor product of individual
qubit state vectors corresponding to each binary digit.

\sphinxAtStartPar
If the \sphinxtitleref{size} parameter is not provided, the size of the state vector is determined
by the length of the binary representation of the \sphinxtitleref{value}.

\end{fulllineitems}

\index{module@\spxentry{module}!utils.matrixInterface@\spxentry{utils.matrixInterface}}\index{utils.matrixInterface@\spxentry{utils.matrixInterface}!module@\spxentry{module}}

\chapter{Matrix Interface}
\label{\detokenize{index:matrix-interface}}\label{\detokenize{index:module-utils.matrixInterface}}\index{matrixInterface (class in utils.matrixInterface)@\spxentry{matrixInterface}\spxextra{class in utils.matrixInterface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.matrixInterface.}}\sphinxbfcode{\sphinxupquote{matrixInterface}}}{\sphinxparam{\DUrole{n}{size}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elements}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This class serves as the Abstract Base Class (ABC or interface) for the
concrete implementations of the matrix object.
\index{add() (utils.matrixInterface.matrixInterface method)@\spxentry{add()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.add}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{add}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise addition of two matrices of the same size.

\end{fulllineitems}

\index{dimension() (utils.matrixInterface.matrixInterface method)@\spxentry{dimension()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.dimension}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{dimension}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the number of rows in a column matrix or the number of rows and columns for a square matrix.

\end{fulllineitems}

\index{equal() (utils.matrixInterface.matrixInterface method)@\spxentry{equal()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.equal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{equal}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Compares two matrices to check for equality, this will be a costly operation so
should be reserved for testing.

\end{fulllineitems}

\index{flat() (utils.matrixInterface.matrixInterface method)@\spxentry{flat()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.flat}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{flat}}}{}{{ $\rightarrow$ \_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}\_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns a flattened version of the matrix, this is equivalent to the transpose for column matrices
so can be used during measurement.

\end{fulllineitems}

\index{matrix (utils.matrixInterface.matrixInterface property)@\spxentry{matrix}\spxextra{utils.matrixInterface.matrixInterface property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.matrix}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{matrix}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }coo\_array\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}\_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{p}{{]}}}}}
\pysigstopsignatures
\sphinxAtStartPar
The matrix property stores the array like object which handles the state
of the object.

\end{fulllineitems}

\index{multiply() (utils.matrixInterface.matrixInterface method)@\spxentry{multiply()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.multiply}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{multiply}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs matrix multiplication of two matrices. The order should be provided as it would
be written.

\end{fulllineitems}

\index{negate() (utils.matrixInterface.matrixInterface method)@\spxentry{negate()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.negate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{negate}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the original matrix with each element set to its own negative.

\end{fulllineitems}

\index{power() (utils.matrixInterface.matrixInterface method)@\spxentry{power()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.power}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{power}}}{\sphinxparam{\DUrole{n}{exponent}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Iteratively performs a tensor product as many times required. Useful for example when raising a
gate to the power of the size of the quantum register to fully entangle the register.

\end{fulllineitems}

\index{reshape() (utils.matrixInterface.matrixInterface method)@\spxentry{reshape()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.reshape}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{reshape}}}{\sphinxparam{\DUrole{n}{rows}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Casts the matrix object into a specific shape e.g. into a column for vectors or
a square for operators.

\end{fulllineitems}

\index{scale() (utils.matrixInterface.matrixInterface method)@\spxentry{scale()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.scale}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{scale}}}{\sphinxparam{\DUrole{n}{factor}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise scalar multiplication by the supplied factor.

\end{fulllineitems}

\index{size (utils.matrixInterface.matrixInterface property)@\spxentry{size}\spxextra{utils.matrixInterface.matrixInterface property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.size}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{size}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }int}}}
\pysigstopsignatures
\sphinxAtStartPar
The size property is used when the parent object is an operator and casts the
array into a size x size matrix.

\end{fulllineitems}

\index{subtract() (utils.matrixInterface.matrixInterface method)@\spxentry{subtract()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.subtract}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{subtract}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise subtraction of two matrices of the same size.

\end{fulllineitems}

\index{tensor() (utils.matrixInterface.matrixInterface method)@\spxentry{tensor()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{tensor}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the tensor product of the matrix with another matrix.

\end{fulllineitems}

\index{toVector() (utils.matrixInterface.matrixInterface method)@\spxentry{toVector()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.toVector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{toVector}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Convenience method to cast a matrix into a column i.e. 1 column and as many rows as elements.

\end{fulllineitems}

\index{update() (utils.matrixInterface.matrixInterface method)@\spxentry{update()}\spxextra{utils.matrixInterface.matrixInterface method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.matrixInterface.matrixInterface.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{update}}}{\sphinxparam{\DUrole{n}{row}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{col}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Updates a specific index of the matrix to the provided value.

\end{fulllineitems}


\end{fulllineitems}

\index{module@\spxentry{module}!utils.sparseMatrix@\spxentry{utils.sparseMatrix}}\index{utils.sparseMatrix@\spxentry{utils.sparseMatrix}!module@\spxentry{module}}

\chapter{Sparse Matrix Implementation}
\label{\detokenize{index:sparse-matrix-implementation}}\label{\detokenize{index:module-utils.sparseMatrix}}\index{sparseMatrix (class in utils.sparseMatrix)@\spxentry{sparseMatrix}\spxextra{class in utils.sparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.sparseMatrix.}}\sphinxbfcode{\sphinxupquote{sparseMatrix}}}{\sphinxparam{\DUrole{n}{size}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elements}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{vector}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures\index{add() (utils.sparseMatrix.sparseMatrix method)@\spxentry{add()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.add}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise addition of two matrices of the same size.

\end{fulllineitems}

\index{dimension() (utils.sparseMatrix.sparseMatrix method)@\spxentry{dimension()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.dimension}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dimension}}}{}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the number of rows in a column matrix or the number of rows and columns for a square matrix.

\end{fulllineitems}

\index{equal() (utils.sparseMatrix.sparseMatrix method)@\spxentry{equal()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.equal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{equal}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Compares two matrices to check for equality, this will be a costly operation so
should be reserved for testing.

\end{fulllineitems}

\index{flat() (utils.sparseMatrix.sparseMatrix method)@\spxentry{flat()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.flat}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flat}}}{}{{ $\rightarrow$ \_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}\_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns a flattened version of the matrix, this is equivalent to the transpose for column matrices
so can be used during measurement.

\end{fulllineitems}

\index{matrix (utils.sparseMatrix.sparseMatrix property)@\spxentry{matrix}\spxextra{utils.sparseMatrix.sparseMatrix property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.matrix}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{matrix}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }coo\_array}}}
\pysigstopsignatures
\sphinxAtStartPar
The matrix property stores the array like object which handles the state
of the object.

\end{fulllineitems}

\index{multiply() (utils.sparseMatrix.sparseMatrix method)@\spxentry{multiply()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.multiply}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{multiply}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs matrix multiplication of two matrices. The order should be provided as it would
be written.

\end{fulllineitems}

\index{negate() (utils.sparseMatrix.sparseMatrix method)@\spxentry{negate()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.negate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{negate}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the original matrix with each element set to its own negative.

\end{fulllineitems}

\index{power() (utils.sparseMatrix.sparseMatrix method)@\spxentry{power()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.power}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{power}}}{\sphinxparam{\DUrole{n}{exponent}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Iteratively performs a tensor product as many times required. Useful for example when raising a
gate to the power of the size of the quantum register to fully entangle the register.

\end{fulllineitems}

\index{reshape() (utils.sparseMatrix.sparseMatrix method)@\spxentry{reshape()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.reshape}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reshape}}}{\sphinxparam{\DUrole{n}{rows}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Casts the matrix object into a specific shape e.g. into a column for vectors or
a square for operators.

\end{fulllineitems}

\index{scale() (utils.sparseMatrix.sparseMatrix method)@\spxentry{scale()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.scale}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\sphinxparam{\DUrole{n}{factor}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise scalar multiplication by the supplied factor.

\end{fulllineitems}

\index{size (utils.sparseMatrix.sparseMatrix property)@\spxentry{size}\spxextra{utils.sparseMatrix.sparseMatrix property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.size}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{size}}}
\pysigstopsignatures
\sphinxAtStartPar
The size property is used when the parent object is an operator and casts the
array into a size x size matrix.

\end{fulllineitems}

\index{subtract() (utils.sparseMatrix.sparseMatrix method)@\spxentry{subtract()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.subtract}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{subtract}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise subtraction of two matrices of the same size.

\end{fulllineitems}

\index{tensor() (utils.sparseMatrix.sparseMatrix method)@\spxentry{tensor()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tensor}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the tensor product of the matrix with another matrix.

\end{fulllineitems}

\index{toVector() (utils.sparseMatrix.sparseMatrix method)@\spxentry{toVector()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.toVector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toVector}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Convenience method to cast a matrix into a column i.e. 1 column and as many rows as elements.

\end{fulllineitems}

\index{update() (utils.sparseMatrix.sparseMatrix method)@\spxentry{update()}\spxextra{utils.sparseMatrix.sparseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.sparseMatrix.sparseMatrix.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\sphinxparam{\DUrole{n}{row}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{col}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.sparseMatrix.sparseMatrix}]{\sphinxcrossref{sparseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Updates a specific index of the matrix to the provided value.

\end{fulllineitems}


\end{fulllineitems}

\index{module@\spxentry{module}!utils.denseMatrix@\spxentry{utils.denseMatrix}}\index{utils.denseMatrix@\spxentry{utils.denseMatrix}!module@\spxentry{module}}

\chapter{Dense Matrix Implementation}
\label{\detokenize{index:dense-matrix-implementation}}\label{\detokenize{index:module-utils.denseMatrix}}\index{denseMatrix (class in utils.denseMatrix)@\spxentry{denseMatrix}\spxextra{class in utils.denseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.denseMatrix.}}\sphinxbfcode{\sphinxupquote{denseMatrix}}}{\sphinxparam{\DUrole{n}{size}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elements}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{vector}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures\index{add() (utils.denseMatrix.denseMatrix method)@\spxentry{add()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.add}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise addition of two matrices of the same size.

\end{fulllineitems}

\index{dimension() (utils.denseMatrix.denseMatrix method)@\spxentry{dimension()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.dimension}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dimension}}}{}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the number of rows in a column matrix or the number of rows and columns for a square matrix.

\end{fulllineitems}

\index{equal() (utils.denseMatrix.denseMatrix method)@\spxentry{equal()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.equal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{equal}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Compares two matrices to check for equality, this will be a costly operation so
should be reserved for testing.

\end{fulllineitems}

\index{flat() (utils.denseMatrix.denseMatrix method)@\spxentry{flat()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.flat}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flat}}}{}{{ $\rightarrow$ \_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}\_SupportsArray\DUrole{p}{{[}}dtype\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }\_NestedSequence\DUrole{p}{{[}}bool\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }complex\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }bytes\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns a flattened version of the matrix, this is equivalent to the transpose for column matrices
so can be used during measurement.

\end{fulllineitems}

\index{matrix (utils.denseMatrix.denseMatrix property)@\spxentry{matrix}\spxextra{utils.denseMatrix.denseMatrix property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.matrix}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{matrix}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }ndarray\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{ }dtype\DUrole{p}{{[}}\_ScalarType\_co\DUrole{p}{{]}}\DUrole{p}{{]}}}}}
\pysigstopsignatures
\sphinxAtStartPar
The matrix property stores the array like object which handles the state
of the object.

\end{fulllineitems}

\index{multiply() (utils.denseMatrix.denseMatrix method)@\spxentry{multiply()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.multiply}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{multiply}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs matrix multiplication of two matrices. The order should be provided as it would
be written.

\end{fulllineitems}

\index{negate() (utils.denseMatrix.denseMatrix method)@\spxentry{negate()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.negate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{negate}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the original matrix with each element set to its own negative.

\end{fulllineitems}

\index{power() (utils.denseMatrix.denseMatrix method)@\spxentry{power()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.power}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{power}}}{\sphinxparam{\DUrole{n}{exponent}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Iteratively performs a tensor product as many times required. Useful for example when raising a
gate to the power of the size of the quantum register to fully entangle the register.

\end{fulllineitems}

\index{reshape() (utils.denseMatrix.denseMatrix method)@\spxentry{reshape()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.reshape}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reshape}}}{\sphinxparam{\DUrole{n}{rows}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cols}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Casts the matrix object into a specific shape e.g. into a column for vectors or
a square for operators.

\end{fulllineitems}

\index{scale() (utils.denseMatrix.denseMatrix method)@\spxentry{scale()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.scale}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\sphinxparam{\DUrole{n}{factor}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise scalar multiplication by the supplied factor.

\end{fulllineitems}

\index{size (utils.denseMatrix.denseMatrix property)@\spxentry{size}\spxextra{utils.denseMatrix.denseMatrix property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.size}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{size}}}
\pysigstopsignatures
\sphinxAtStartPar
The size property is used when the parent object is an operator and casts the
array into a size x size matrix.

\end{fulllineitems}

\index{subtract() (utils.denseMatrix.denseMatrix method)@\spxentry{subtract()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.subtract}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{subtract}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Performs elementwise subtraction of two matrices of the same size.

\end{fulllineitems}

\index{tensor() (utils.denseMatrix.denseMatrix method)@\spxentry{tensor()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tensor}}}{\sphinxparam{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the tensor product of the matrix with another matrix.

\end{fulllineitems}

\index{toVector() (utils.denseMatrix.denseMatrix method)@\spxentry{toVector()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.toVector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toVector}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Convenience method to cast a matrix into a column i.e. 1 column and as many rows as elements.

\end{fulllineitems}

\index{update() (utils.denseMatrix.denseMatrix method)@\spxentry{update()}\spxextra{utils.denseMatrix.denseMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.denseMatrix.denseMatrix.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\sphinxparam{\DUrole{n}{row}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{col}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{{ $\rightarrow$ {\hyperref[\detokenize{index:utils.denseMatrix.denseMatrix}]{\sphinxcrossref{denseMatrix}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Updates a specific index of the matrix to the provided value.

\end{fulllineitems}


\end{fulllineitems}

\index{module@\spxentry{module}!utils.tensor@\spxentry{utils.tensor}}\index{utils.tensor@\spxentry{utils.tensor}!module@\spxentry{module}}

\chapter{Tensor Module}
\label{\detokenize{index:tensor-module}}\label{\detokenize{index:module-utils.tensor}}
\sphinxAtStartPar
This module provides classes for working with operators and vectors in a quantum computing context.
It includes the \sphinxtitleref{Operator} class for representing quantum operators and the \sphinxtitleref{Vector} class for
representing quantum state vectors.

\sphinxAtStartPar
The \sphinxtitleref{Operator} class supports operations tensor products, addition, subtraction,
exponentiation, and matrix multiplication. It also provides methods for updating matrix elements,
negating the matrix, and scaling the matrix by a value.

\sphinxAtStartPar
The \sphinxtitleref{Vector} class supports operations tensor products, outer products, addition, subtraction,
scalar multiplication, and exponentiation. It also provides methods for applying an operator to a
vector and checking equality between vectors.
\index{Operator (class in utils.tensor)@\spxentry{Operator}\spxextra{class in utils.tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Operator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.tensor.}}\sphinxbfcode{\sphinxupquote{Operator}}}{\sphinxparam{\DUrole{n}{size}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elements}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This class represents a quantum operator as a sparse matrix.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
size (int): The size of the operator matrix.
elements (Union{[}list, coo\_array{]}): The matrix elements as a list or a \sphinxtitleref{coo\_array}.

\sphinxlineitem{Attributes:}
\sphinxAtStartPar
matrix (coo\_array): The sparse matrix representation of the operator.
size (int): The size of the operator matrix.

\end{description}
\index{equal() (utils.tensor.Operator method)@\spxentry{equal()}\spxextra{utils.tensor.Operator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Operator.equal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{equal}}}{\sphinxparam{\DUrole{n}{target}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if the operator is equal to another operator.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
target (Operator): The operator to compare with.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
bool: True if the operators are equal, False otherwise.

\end{description}

\end{fulllineitems}

\index{negate() (utils.tensor.Operator method)@\spxentry{negate()}\spxextra{utils.tensor.Operator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Operator.negate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{negate}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Negates the operator matrix.
\begin{description}
\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The negated operator.

\end{description}

\end{fulllineitems}

\index{scale() (utils.tensor.Operator method)@\spxentry{scale()}\spxextra{utils.tensor.Operator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Operator.scale}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\sphinxparam{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Scales the operator matrix by a value.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
value (float): The scaling factor.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The scaled operator.

\end{description}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{tensor() (utils.tensor.Operator method)@\spxentry{tensor()}\spxextra{utils.tensor.Operator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Operator.tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tensor}}}{\sphinxparam{\DUrole{n}{target}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.tensor.Operator}]{\sphinxcrossref{Operator}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the tensor product of the operator with another operator.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
target (Operator): The operator to compute the tensor product with.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The tensor product operator.

\end{description}

\end{fulllineitems}

\index{update() (utils.tensor.Operator method)@\spxentry{update()}\spxextra{utils.tensor.Operator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Operator.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\sphinxparam{\DUrole{n}{row}}\sphinxparamcomma \sphinxparam{\DUrole{n}{column}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Updates a specific element of the operator matrix.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
row (int): The row index of the element to update.
column (int): The column index of the element to update.
value (float): The new value of the element.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The updated operator.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Vector (class in utils.tensor)@\spxentry{Vector}\spxextra{class in utils.tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Vector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.tensor.}}\sphinxbfcode{\sphinxupquote{Vector}}}{\sphinxparam{\DUrole{n}{elements}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }{\hyperref[\detokenize{index:utils.matrixInterface.matrixInterface}]{\sphinxcrossref{matrixInterface}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This class represents a quantum state vector.
\begin{description}
\sphinxlineitem{Args:}\begin{description}
\sphinxlineitem{elements (Union{[}list{[}int{]}, int, coo\_array{]}): The vector elements as a list, an integer (0 or 1),}
\sphinxAtStartPar
or a \sphinxtitleref{coo\_array}.

\end{description}

\sphinxlineitem{Attributes:}
\sphinxAtStartPar
vector (coo\_array): The sparse vector representation.
dimension (int): The dimension of the vector.

\end{description}
\index{apply() (utils.tensor.Vector method)@\spxentry{apply()}\spxextra{utils.tensor.Vector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Vector.apply}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply}}}{\sphinxparam{\DUrole{n}{operator}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.tensor.Operator}]{\sphinxcrossref{Operator}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Applies an operator to the vector.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
operator (Operator): The operator to apply.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Vector: The resulting vector after applying the operator.

\end{description}

\end{fulllineitems}

\index{equal() (utils.tensor.Vector method)@\spxentry{equal()}\spxextra{utils.tensor.Vector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Vector.equal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{equal}}}{\sphinxparam{\DUrole{n}{target}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.tensor.Vector}]{\sphinxcrossref{Vector}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if the vector is equal to another vector.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
target (Vector): The vector to compare with.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
bool: True if the vectors are equal, False otherwise.

\end{description}

\end{fulllineitems}

\index{measure() (utils.tensor.Vector method)@\spxentry{measure()}\spxextra{utils.tensor.Vector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Vector.measure}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{measure}}}{\sphinxparam{\DUrole{n}{basis}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.tensor.Vector}]{\sphinxcrossref{Vector}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Measures the vector with respect to a basis vector.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
basis (Vector): The basis vector to measure against.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
float: The measurement result.

\end{description}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{scale() (utils.tensor.Vector method)@\spxentry{scale()}\spxextra{utils.tensor.Vector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Vector.scale}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\sphinxparam{\DUrole{n}{scalar}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Scales the vector by a value.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
value (float): The scaling factor.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Vector: The scaled vector.

\end{description}

\end{fulllineitems}

\index{tensor() (utils.tensor.Vector method)@\spxentry{tensor()}\spxextra{utils.tensor.Vector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:utils.tensor.Vector.tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tensor}}}{\sphinxparam{\DUrole{n}{target}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{index:utils.tensor.Vector}]{\sphinxcrossref{Vector}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes the tensor product of the vector with another vector.
\begin{description}
\sphinxlineitem{Args:}
\sphinxAtStartPar
target (Vector): The vector to compute the tensor product with.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Vector: The tensor product vector.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{module@\spxentry{module}!gates@\spxentry{gates}}\index{gates@\spxentry{gates}!module@\spxentry{module}}

\chapter{Gates Module}
\label{\detokenize{index:gates-module}}\label{\detokenize{index:module-gates}}
\sphinxAtStartPar
This module provides the implementation of quantum gates used in Grover’s algorithm.
The \sphinxtitleref{Gate} class contains methods for creating the Hadamard gate, oracle gate,
reflection gate, and identity gate.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This code is still under development and until the version
is incremented to a 1.* you should not trust any of this
documentation.
\end{sphinxadmonition}
\index{Gate (class in gates)@\spxentry{Gate}\spxextra{class in gates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:gates.Gate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{gates.}}\sphinxbfcode{\sphinxupquote{Gate}}}{\sphinxparam{\DUrole{n}{dimension}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This is the gate class which contains the gates we need to implement
Grover’s algorithm.

\sphinxAtStartPar
When we initialise, we declare the dimension of the quantum
register so that the gates (except the Hadamard) can be provided in
the correct dimension.

\sphinxAtStartPar
The Hadamard gate is scaled (using tensor products) at the point
of implementation to make the application more obvious.
\index{h() (gates.Gate method)@\spxentry{h()}\spxextra{gates.Gate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:gates.Gate.h}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{h}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Single\sphinxhyphen{}qubit Hadamard gate.

\sphinxAtStartPar
This gate is a \(\pi\) rotation about the X+Z axis, and has the effect
of changing computation basis from \(|0\rangle,|1\rangle\) to
\(|+\rangle,|-\rangle\) and vice\sphinxhyphen{}versa.

\sphinxAtStartPar
\sphinxstylestrong{Matrix Representation:}
\begin{equation*}
\begin{split}H = \frac{1}{\sqrt{2}}
    \begin{pmatrix}
        1 & 1 \\
        1 & -1
    \end{pmatrix}\end{split}
\end{equation*}
\end{fulllineitems}

\index{i() (gates.Gate method)@\spxentry{i()}\spxextra{gates.Gate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:gates.Gate.i}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{i}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Identity gate.

\sphinxAtStartPar
The identity gate performs no operation on the quantum state. It is
represented by the identity matrix of size determined by the dimension
of the quantum register.

\sphinxAtStartPar
\sphinxstylestrong{Matrix Representation:}
\begin{equation*}
\begin{split}I = 
    \begin{pmatrix}
        1 & 0 \\
        0 & 1
    \end{pmatrix}\end{split}
\end{equation*}\begin{description}
\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The identity gate as an \sphinxtitleref{Operator} object.

\end{description}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{oracle() (gates.Gate method)@\spxentry{oracle()}\spxextra{gates.Gate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:gates.Gate.oracle}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{oracle}}}{\sphinxparam{\DUrole{n}{target}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Oracle gate for Grover’s algorithm.

\sphinxAtStartPar
The oracle gate marks the target state by flipping its phase. It is a
diagonal matrix with all elements on the diagonal equal to 1, except for
the element corresponding to the target state, which is \sphinxhyphen{}1.

\sphinxAtStartPar
\sphinxstylestrong{Matrix Representation:}
\begin{equation*}
\begin{split}O = 
    \begin{pmatrix}
        1 & 0 \\
        0 & -1
    \end{pmatrix}\end{split}
\end{equation*}\begin{description}
\sphinxlineitem{Params:}
\sphinxAtStartPar
target (int): The target state to be marked by the oracle.

\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The oracle gate as an \sphinxtitleref{Operator} object.

\end{description}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
unsure of this gate description, maybe worth to check others as well
\end{sphinxadmonition}

\end{fulllineitems}

\index{reflection() (gates.Gate method)@\spxentry{reflection()}\spxextra{gates.Gate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:gates.Gate.reflection}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reflection}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Reflection gate for Grover’s algorithm.

\sphinxAtStartPar
The reflection gate reflects the amplitudes of all states about the average
amplitude. It is a diagonal matrix with the first element on the diagonal
equal to 1 and all other elements equal to \sphinxhyphen{}1.

\sphinxAtStartPar
\sphinxstylestrong{Matrix Representation:}
\begin{equation*}
\begin{split}R = 
    \begin{pmatrix}
        1 & 0 \\
        0 & -1
    \end{pmatrix}\end{split}
\end{equation*}\begin{description}
\sphinxlineitem{Returns:}
\sphinxAtStartPar
Operator: The reflection gate as an \sphinxtitleref{Operator} object

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{module@\spxentry{module}!tests.test\_tensor@\spxentry{tests.test\_tensor}}\index{tests.test\_tensor@\spxentry{tests.test\_tensor}!module@\spxentry{module}}

\chapter{Tensor Module Test Suite}
\label{\detokenize{index:tensor-module-test-suite}}\label{\detokenize{index:module-tests.test_tensor}}
\sphinxAtStartPar
This module tests the classes included in the tensor module.
\index{TestOperator (class in tests.test\_tensor)@\spxentry{TestOperator}\spxextra{class in tests.test\_tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:tests.test_tensor.TestOperator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{tests.test\_tensor.}}\sphinxbfcode{\sphinxupquote{TestOperator}}}{\sphinxparam{\DUrole{n}{methodName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}runTest\textquotesingle{}}}}{}
\pysigstopsignatures\index{test\_operator\_tensor\_product\_vs\_notes() (tests.test\_tensor.TestOperator method)@\spxentry{test\_operator\_tensor\_product\_vs\_notes()}\spxextra{tests.test\_tensor.TestOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:tests.test_tensor.TestOperator.test_operator_tensor_product_vs_notes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_operator\_tensor\_product\_vs\_notes}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Tensor Product of Hadamard, Identity and Hadamard, as presented in
the slides \sphinxhyphen{} \(H \otimes \mathbb{I} \otimes H\).

\sphinxAtStartPar
This manually creates the hadamard gates and performs the tensor
product using the \sphinxcode{\sphinxupquote{tensor()}} method.

\sphinxAtStartPar
The result is compared against the result in the slides:
\begin{equation*}
\begin{split}H \otimes \mathbb{I} \otimes H = \frac{1}{2}
    \begin{pmatrix}
        1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\
        1 & -1 & 0 & 0 & 1 & -1 & 0 & 0 \\
        0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
        0 & 0 & 1 & -1 & 0 & 0 & 1 & -1 \\
        1 & 1 & 0 & 0 & -1 & -1 & 0 & 0 \\
        1 & -1 & 0 & 0 & 1 & -1 & 0 & 0 \\
        0 & 0 & 1 & 1 & 0 & 0 & -1 & -1 \\
        0 & 0 & 1 & -1 & 0 & 0 & -1 & 1
    \end{pmatrix}\end{split}
\end{equation*}
\end{fulllineitems}


\end{fulllineitems}

\index{TestVector (class in tests.test\_tensor)@\spxentry{TestVector}\spxextra{class in tests.test\_tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:tests.test_tensor.TestVector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{tests.test\_tensor.}}\sphinxbfcode{\sphinxupquote{TestVector}}}{\sphinxparam{\DUrole{n}{methodName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}runTest\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This class aims to provide end to end testing of the
Vector class within the tensor module.

\sphinxAtStartPar
The purpose of each test and the method by which it
is validated is outlined below.
\index{test\_vector\_construction() (tests.test\_tensor.TestVector method)@\spxentry{test\_vector\_construction()}\spxextra{tests.test\_tensor.TestVector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:tests.test_tensor.TestVector.test_vector_construction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_vector\_construction}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This test aims to check…

\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{e}
\item\relax\sphinxstyleindexentry{example}\sphinxstyleindexpageref{index:\detokenize{module-example}}
\indexspace
\bigletter{g}
\item\relax\sphinxstyleindexentry{gates}\sphinxstyleindexpageref{index:\detokenize{module-gates}}
\indexspace
\bigletter{q}
\item\relax\sphinxstyleindexentry{qc}\sphinxstyleindexpageref{index:\detokenize{module-qc}}
\indexspace
\bigletter{t}
\item\relax\sphinxstyleindexentry{tests.test\_tensor}\sphinxstyleindexpageref{index:\detokenize{module-tests.test_tensor}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{utils.denseMatrix}\sphinxstyleindexpageref{index:\detokenize{module-utils.denseMatrix}}
\item\relax\sphinxstyleindexentry{utils.matrixInterface}\sphinxstyleindexpageref{index:\detokenize{module-utils.matrixInterface}}
\item\relax\sphinxstyleindexentry{utils.sparseMatrix}\sphinxstyleindexpageref{index:\detokenize{module-utils.sparseMatrix}}
\item\relax\sphinxstyleindexentry{utils.state\_vector}\sphinxstyleindexpageref{index:\detokenize{module-utils.state_vector}}
\item\relax\sphinxstyleindexentry{utils.tensor}\sphinxstyleindexpageref{index:\detokenize{module-utils.tensor}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}